const entities = require('entities')

const XML_DECL = '<?xml version="1.0" encoding="UTF-8"?>'
const XMLNS = 'http://www.sitemaps.org/schemas/sitemap/0.9'
const URLSET = 'urlset'
const URL = 'url'
const LOC = 'loc'
const CHANGEFREQ = 'changefreq'
const PRIORITY = 'priority'
const LASTMOD = 'lastmod'

const IMAGE = 'image:image'
const IMAGE_LOC = 'image:loc'
const IMAGE_TITLE = 'image:title'
const IMAGE_CAPTION = 'image:caption'
const IMAGE_GEO = 'image:geo_location'
const IMAGE_LICENSE = 'image:license'

const VIDEO = 'video:video'
const VIDEO_LOC = 'video:content_loc'
const VIDEO_PLAYER_LOC = 'video:player_loc'

const VIDEO_MAP = [
  {attr: 'title'},
  {attr: 'data-description'},
  {attr: 'data-thumbnail-loc'},
  {attr: 'data-duration'},
  {attr: 'data-expiration-date'},
  {attr: 'data-rating'},
  {attr: 'data-view-count'},
  {attr: 'data-publication-date'},
  {attr: 'data-family-friendly'},
  {
    attr: 'data-tag',
    element: (xml, value, item) => {
      const tags = value.split(/\s*,\s*/)
      tags.forEach((value) => {
        xml += tag(item.name, value, true)
      })
      return xml
    }
  },
  {attr: 'data-category'},
  {
    attr: 'data-restriction',
    attributes: (node, adapter) => {
      const attr = adapter.getAttribute(node, 'data-restriction-relationship')
      if (attr) {
        return {relationship: attr.value}
      }
    }
  },
  {
    attr: 'data-gallery-loc',
    attributes: (node, adapter) => {
      const attr = adapter.getAttribute(node, 'data-gallery-loc-title')
      if (attr) {
        return {title: attr.value}
      }
    }
  },
  {
    attr: 'data-price',
    attributes: (node, adapter) => {
      const attr = adapter.getAttribute(node, 'data-price-currency')
      if (attr) {
        return {currency: attr.value}
      }
    }
  },
  {attr: 'data-requires-subscription'},
  {
    attr: 'data-uploader',
    attributes: (node, adapter, options) => {
      const attr = adapter.getAttribute(node, 'data-uploader-info')
      if (attr) {
        return {info: options.absolute(attr.value)}
      }
    }
  },
  {
    attr: 'data-platform',
    attributes: (node, adapter, options) => {
      const attr = adapter.getAttribute(node, 'data-platform-relationship')
      if (attr) {
        return {relationship: attr.value}
      }
    }
  },
  {attr: 'data-live'}
].map((item) => {
  let ptn = /^data-/
  if (ptn.test(item.attr)) {
    item.name = item.attr.replace(/^data-/, 'video:')
  } else {
    item.name = 'video:' + item.attr
  }
  item.name = item.name.replace(/-/g, '_')
  return item
})

const FREQUENCY = [
  'always',
  'hourly',
  'daily',
  'weekly',
  'monthly',
  'yearly',
  'never'
]

function tag (name, attrs, close) {
  let closed = `</${name}>`
  let tag = ''
  if (attrs && typeof attrs === 'boolean') {
    return closed
  }

  tag = `<${name}`
  if (typeof attrs === 'object') {
    for (let k in attrs) {
      tag += ` ${k}="${entities.encodeXML(attrs[k])}"`
    }
  }
  tag += '>'

  // treat as child text node
  if (typeof attrs === 'string') {
    tag += entities.encodeXML(attrs)
  } else if (typeof close === 'string') {
    tag += entities.encodeXML(close)
  }

  if (close) {
    tag += closed
  }

  return tag
}

/**
 *  Renders the sitemap as XML.
 *
 *  @class XmlRenderer
 */
class XmlRenderer {

  /**
   *  Render the XML format.
   *
   *  @static {function} render
   *  @param {Object} context the processing context.
   *  @param {Object} sitemap raw sitemap data.
   *
   *  @option {String=false} image include document images.
   *  @option {String=false} video include document videos.
   *  @option {Array} rules list of document rules.
   *
   *  @returns an object with the xml file `content`.
   */
  static render (context, sitemap, options = {}) {
    let xml = XML_DECL
    let rules = sitemap.rules
    let rule
    let priority
    let file
    let attrs =
      {
        xmlns: XMLNS,
        'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
        'xsi:schemaLocation': 'http://www.sitemaps.org/schemas/sitemap/0.9 ' +
          'http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd'
      }

    if (options.image) {
      attrs['xmlns:image'] = 'http://www.google.com/schemas/sitemap-image/1.1'
    }

    if (options.video) {
      attrs['xmlns:video'] = 'http://www.google.com/schemas/sitemap-video/1.1'
    }

    xml += tag(URLSET, attrs)

    sitemap.files.forEach((info) => {
      xml += tag(URL)
      xml += tag(LOC, info.url, true)

      file = info.doc.file

      /* istanbul ignore else: always have stat in test env */
      if (file.stat) {
        xml += tag(LASTMOD, file.stat.mtime.toISOString(), true)
      }

      if (rules.length) {
        rule = XmlRenderer.getRule(info.href, rules)
        if (rule) {
          if (rule.changefreq && ~FREQUENCY.indexOf(rule.changefreq)) {
            xml += tag(CHANGEFREQ, rule.changefreq, true)
          }

          if (rule.priority !== undefined) {
            priority = rule.priority
            if (typeof priority === 'string') {
              priority = Number(priority)
              if (isNaN(priority)) {
                // default priority
                priority = 0.5
              }
            }
            priority = Math.max(0, priority)
            priority = Math.min(1, priority)
            priority = priority.toString()
            // follow the spec to the letter
            if (priority === '1') {
              priority = '1.0'
            } else if (priority === '0') {
              priority = '0.0'
            }
            xml += tag(PRIORITY, priority, true)
          }
        }
      }

      if (options.image) {
        xml = XmlRenderer.getImages(xml, info.doc, options)
      }

      if (options.video) {
        xml = XmlRenderer.getVideos(xml, info.doc, options)
      }

      xml += tag(URL, true)
    })
    xml += tag(URLSET, true)
    return {content: xml}
  }

  /**
   *  Get the images XML for a document.
   *
   *  @static {function} getImages
   *  @private
   */
  static getImages (xml, doc, options) {
    const adapter = doc.file.ast.html.adapter
    const abs = options.absolute
    const limit = 1000
    let count = 0
    let resource
    for (let i = 0; i < doc.resources.length; i++) {
      resource = doc.resources[i]
      const node = resource.node
      let title, caption, license, geo
      if (node.nodeName === 'img') {
        /* istanbul ignore next: not mocking a thousand images */
        if (count >= limit) {
          return xml
        }
        xml += tag(IMAGE)
        title = adapter.getAttribute(node, 'title')
        caption = adapter.getAttribute(node, 'data-caption')
        license = adapter.getAttribute(node, 'data-license')
        geo = adapter.getAttribute(node, 'data-geo-location')

        // image URI
        xml += tag(IMAGE_LOC, abs(resource.uri), true)

        if (title) {
          xml += tag(IMAGE_TITLE, title.value, true)
        }

        if (caption) {
          xml += tag(IMAGE_CAPTION, caption.value, true)
        }

        if (geo) {
          xml += tag(IMAGE_GEO, geo.value, true)
        }

        if (license) {
          xml += tag(IMAGE_LICENSE, license.value, true)
        }

        xml += tag(IMAGE, true)

        count++
      }
    }
    return xml
  }

  /**
   *  Get the videos XML for a document.
   *
   *  @static {function} getVideos
   *  @private
   */
  static getVideos (xml, doc, options) {
    const adapter = doc.file.ast.html.adapter
    const abs = options.absolute
    const limit = 1000
    let count = 0
    let resource
    let node
    let src
    for (let i = 0; i < doc.resources.length; i++) {
      resource = doc.resources[i]
      node = resource.node
      if (node.nodeName === 'video') {
        /* istanbul ignore next: not mocking a thousand videos */
        if (count >= limit) {
          return xml
        }
        xml += tag(VIDEO)

        // video URI
        xml += tag(VIDEO_LOC, abs(resource.uri), true)

        node.childNodes.forEach((child) => {
          if (child.nodeName === 'embed') {
            src = adapter.getAttribute(child, 'src')
            if (src) {
              xml += tag(VIDEO_PLAYER_LOC, abs(src.value), true)
            }
          }
        })

        VIDEO_MAP.forEach((item) => {
          let attrs
          let attr = adapter.getAttribute(node, item.attr)
          if (!attr) {
            return
          }

          if (item.element) {
            xml += item.element(xml, attr.value, item)
            return
          }

          if (item.attributes) {
            attrs = item.attributes(node, adapter, options)
          }

          xml += tag(item.name, attrs, attr.value)
        })

        xml += tag(VIDEO, true)

        count++
      }
    }
    return xml
  }

  /**
   *  Find the first rule that matches a document URL.
   *
   *  @static {function} getRule
   *  @private
   */
  static getRule (url, rules) {
    let ptn
    for (let i = 0; i < rules.length; i++) {
      ptn = rules[i].test
      if (ptn.test(url)) {
        return rules[i]
      }
    }
  }

  /**
   *  Get the file extension for the `xml` format.
   *
   *  @static {property} extension
   */
  static get extension () {
    return 'xml'
  }
}

module.exports = XmlRenderer
