const url = require('url')

class TreeNode {
  constructor (item, id, doc) {
    for (let k in item) {
      this[k] = item[k]
    }

    // the `id` field is used internally so is hidden from the JSON output
    Object.defineProperty(
      this, 'id', {enumerable: false, value: id})

    // hide document from json serialization
    if (doc) {
      Object.defineProperty(
        this, 'doc', {enumerable: false, value: doc})
    }
  }

  get childNodes () {
    return this.nodes
  }

  get firstChild () {
    return this.nodes[0]
  }

  get prev () {
    if (this.parentNode) {
      let nodes = this.parentNode.childNodes
      return nodes[nodes.indexOf(this) - 1]
    }
  }

  get next () {
    if (this.parentNode) {
      let nodes = this.parentNode.childNodes
      return nodes[nodes.indexOf(this) + 1]
    }
  }

  walk (it) {
    it(this, {enter: true})
    this.childNodes.forEach((node) => {
      node.walk(it)
    })
    it(this, {enter: false})
  }
}

/**
 *  Renders the sitemap as JSON and generates an AST of the sitemap structure.
 *
 *  @class JsonRenderer
 */
class JsonRenderer {

  static tree (context, sitemap, urls, opts = {}) {
    const index = opts.index
    const sortField = opts.sortField || 'href'
    const labelField = opts.labelField || 'label'
    const nodesField = opts.nodesField || 'nodes'
    const map = new TreeNode({nodes: []})

    function sort (nodes) {
      return nodes.sort(function (a, b) {
        let av = a[sortField]
        let bv = b[sortField]

        /*
        if (av === bv) {
          return 0
        }
        */
        return av > bv ? 1 : -1
      })
    }

    function getItem (item) {
      item[labelField] = item.href
      item[nodesField] = item[nodesField] || []
      item.uri = url.parse(item.href)
      // strip leading and trailing slashes from path before split
      item.pathname = item.href.replace(/^\//, '').replace(/\/+$/, '')
      item.parts = item.pathname.split('/')
      let id = item.name = item.parts[item.parts.length - 1]
      item.parents = item.parts.slice()
      item.parents.pop()
      item.parent = item.parents.join('/')

      if (!item.type) {
        item.type = 'page'
      }

      let doc

      if (item.key) {
        doc = context.graph.map[item.key]
      }
      return new TreeNode(item, id, doc)
    }

    function addItem (parent, item) {
      parent.nodes.push(item)
      Object.defineProperty(
        item, 'parentNode', {enumerable: false, value: parent})
      return item
    }

    function mergeIndex (parent, item) {
      // merge fields except the node list
      for (let k in item) {
        if (k === nodesField || k === 'id') {
          continue
        }
        parent[k] = item[k]
      }

      parent.type = 'index'

      // non-enumerable properties
      Object.defineProperty(
        parent, 'doc', {enumerable: false, value: item.doc})
      Object.defineProperty(
        parent, 'file', {enumerable: false, value: item.doc.file})
    }

    function addToParent (parts, item) {
      // start at the root for the parent hierarchy
      let nodes = map[nodesField]
      let pathname = ''
      let i, part
      let parent = map
      let current

      function findParent (part) {
        for (let j = 0; j < nodes.length; j++) {
          if (nodes[j].id === part) {
            return nodes[j]
          }
        }
      }

      function createParent () {
        let item = getItem({href: pathname, type: 'directory'})
        addItem(parent, item)
        return item
      }

      // top-level
      if (parts.length === 1) {
        if (item.name === index) {
          mergeIndex(map, item)
        } else {
          addItem(map, item)
        }
      // nested href
      } else {
        for (i = 0; i < parts.length; i++) {
          part = parts[i]
          pathname += '/' + part
          // find or create parent hierarchy
          if (i < parts.length - 1) {
            current = findParent(part)
            // parent node does not exist so create a new parent
            if (!current) {
              parent = createParent(pathname)
            } else {
              parent = current
            }

            nodes = parent.nodes
          } else {
            // handle child index pages
            if (item.name === index) {
              mergeIndex(parent, item)
            } else {
              addItem(parent, item)
            }
          }
        }
      }
    }

    let item
    for (let i = 0; i < urls.length; i++) {
      item = getItem(urls[i])
      addToParent(item.parts, item)
    }

    // recursive sort of node tree
    function walk (parent, nodes) {
      parent.nodes = sort(nodes)
      nodes.forEach((node) => {
        walk(node, node.nodes)
      })
    }

    walk(map, map.nodes)

    return map
  }

  static parse (context, sitemap, options = {indent: 0}) {
    const ast = {base: options.base, urls: []}
    ast.urls = sitemap.files.map((info) => {
      return {url: info.url, href: info.href, key: info.key}
    })
    ast.tree = JsonRenderer.tree(context, sitemap, ast.urls, options)
    return ast
  }

  static render (context, sitemap, options = {indent: 0}) {
    const ast = JsonRenderer.parse(context, sitemap, options)
    return {
      ast: ast,
      content: JSON.stringify(ast, undefined, options.indent)
    }
  }

  /**
   *  Get the file extension for the `json` format.
   *
   *  @static {property} extension
   */
  static get extension () {
    return 'json'
  }
}

module.exports = JsonRenderer
