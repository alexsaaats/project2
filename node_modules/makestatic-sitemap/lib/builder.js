/**
 *  Default implementation for generating a DOM structure of the sitemap
 *  within the sitemap template file.
 *
 *  It is recommended that you use this default implementation and style the
 *  lists but if you really want to use different elements for the sitemap you
 *  can supply an alternative builder class as a renderer option.
 *
 *  @class HtmlBuilder
 */
class HtmlBuilder {

  /**
   *  Create an HtmlBuilder.
   *
   *  @constructor HtmlBuilder
   *  @param {Object} context the processing context.
   *  @param {Object} sitemap raw sitemap data.
   *  @param {Object} ast the sitemap AST.
   *  @param {Object} template reference to the sitemap template.
   *  @param {Object} options the renderer options.
   *
   *  @returns a string href.
   */
  constructor (context, sitemap, ast, template, options) {
    this.context = context
    this.sitemap = sitemap
    this.ast = ast
    this.template = template
    this.options = options
    this.document = template.ast
    this.adapter = this.document.adapter

    this.mapping = {}
  }

  getRootHref (node) {
    let href = '/' + node.parts.join('/')
    if (this.options.clean && node.name === this.options.index) {
      href = node.parents.join('/')
      if (href && this.options.slash) {
        href += '/'
      }
      href = '/' + href
    }
    return href
  }

  /**
   *  Get an `href` attribute value.
   *
   *  @function getHref
   *  @member HtmlBuilder
   *  @param {Object} node the sitemap tree node.
   *
   *  @returns a string href.
   */
  getHref (node) {
    let href
    if (this.options.strategy === 'relative') {
      const useDirectory = node.type === 'index' && this.options.clean
      const path = require('path')
      href = node.href.replace(/^\//, '')
      if (useDirectory) {
        href = node.parents.join('/')
      }
      let parts = this.options.template.split(path.sep)
      parts.pop()
      parts = parts.map(() => {
        return '..'
      })
      href = parts.join('/') + '/' + href
      if (useDirectory && this.options.slash && !/\/$/.test(href)) {
        href += '/'
      }
    } else {
      href = this.getRootHref(node)
      if (this.options.strategy === 'absolute') {
        href = this.options.base + href
      }
    }
    return href
  }

  /**
   *  Get the title for a node.
   *
   *  This value is used for the link text and the link `title` attribute.
   *
   *  @function getTitle
   *  @member HtmlBuilder
   *  @param {Object} node the sitemap tree node.
   *
   *  @returns a string title.
   */
  getTitle (node) {
    let title = node.name
    let el
    const doc = node.doc
    el = doc.ast.querySelector('title')
    if (el && el.childNodes.length && el.childNodes[0].value !== undefined) {
      title = el.childNodes[0].value
    }
    return title
  }

  /**
   *  Get the text for a link node.
   *
   *  Prefers a `title` when available otherwise uses the page name.
   *
   *  @function getLinkText
   *  @member HtmlBuilder
   *  @param {Object} node the sitemap tree node.
   *
   *  @returns a string for the link text.
   */
  getLinkText (node) {
    return this.getTitle(node)
  }

  /**
   *  Get the description for a node.
   *
   *  Extract the `content` attribute from a `meta` element with `name` set to
   *  `description`.
   *
   *  @function getDescription
   *  @member HtmlBuilder
   *  @param {Object} node the sitemap tree node.
   *
   *  @returns a string description.
   */
  getDescription (node) {
    let description
    let el
    const doc = node.doc
    el = doc.ast.querySelector('meta[name="description"]')
    if (el) {
      description = this.adapter.getAttributeValue(el, 'content')
    }
    return description
  }

  /**
   *  Create the root element to append as a child of the element with an `id`
   *  of `sitemap` in the template file.
   *
   *  This implementation returns a `ul` element.
   *
   *  @function getRootElement
   *  @member HtmlBuilder
   *  @param {Object} node the sitemap AST node.
   *
   *  @returns an element.
   */
  getRootElement (node) {
    return this.adapter.createElement('ul')
  }

  /**
   *  Get an element for each tree node item.
   *
   *  This implementation returns a `li` element.
   *
   *  @function getItemElement
   *  @member HtmlBuilder
   *  @param {Object} node the sitemap AST node.
   *
   *  @returns an element.
   */
  getItemElement (node) {
    return this.adapter.createElement('li')
  }

  /**
   *  Invoked when a node is entered.
   *
   *  @function onEnter
   *  @param {Object} node the sitemap tree node.
   */
  onEnter (node) {
    let href = this.getHref(node)
    let item = this.getItemElement(node)

    if (node.type !== 'directory') {
      let description = this.getDescription(node)
      let link = this.adapter.createElement(
        'a', {href: href, title: this.getTitle(node)})
      let text = this.adapter.createTextNode(this.getLinkText(node))
      this.adapter.appendChild(link, text)
      this.adapter.appendChild(item, link)
      if (description) {
        let para = this.adapter.createElement('p')
        this.adapter.appendChild(para, this.adapter.createTextNode(description))
        this.adapter.appendChild(item, para)
      }
    } else {
      this.adapter.appendChild(item, this.adapter.createTextNode(node.name))
    }

    // check if we have a shared parent
    if (!node.childNodes.length &&
        this.last &&
        // must have some parents
        node.parents.length === this.last.parents.length &&
        // must have at least one shared parent
        this.last.parents[0] === node.parents[0]) {
      let last, part, i
      for (i = 0; i < node.parents.length; i++) {
        last = this.last.parents[i]
        part = node.parents[i]
        if (last !== part) {
          break
        }
      }

      const key = node.parents.slice(0, i).join('/')
      this.current = this.mapping[key]
      this.adapter.appendChild(this.current, item)
      return
    }

    // about to go deeper, create new parent list
    if (node.childNodes.length) {
      this.adapter.appendChild(this.current, item)
      this.current = this.adapter.createElement('ul')
      this.adapter.appendChild(item, this.current)
      this.parents.push(this.current)
      this.mapping[node.parent] = this.current
    } else {
      let key = node.parent
      if (node.type === 'index' && node.parentNode) {
        key = node.parentNode.parents.join('/')
      }
      if (this.mapping[key]) {
        this.current = this.mapping[key]
        this.adapter.appendChild(this.current, item)
      } else {
        this.adapter.appendChild(this.current, item)
      }
    }
  }

  /**
   *  Invoked when a node is exited.
   *
   *  @function onExit
   *  @param {Object} node the sitemap tree node.
   */
  onExit (node) {
    this.last = node
    if (node.childNodes.length) {
      this.current = this.parents.pop()
    }
  }

  /**
   *  Main DOM builder function, generates unordered lists representing the
   *  sitemap.
   *
   *  @function build
   *  @member HtmlBuilder
   *  @param {Object} parent the parent DOM node.
   */
  build (parent) {
    let tree = this.ast.tree
    this.current = this.getRootElement(tree)
    this.adapter.appendChild(parent, this.current)
    this.parents = [this.current]
    tree.walk((node, event) => {
      if (event.enter) {
        this.onEnter(node)
      } else {
        this.onExit(node)
      }
    })
  }
}

module.exports = HtmlBuilder
