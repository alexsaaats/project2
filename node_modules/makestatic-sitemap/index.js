const url = require('url')
const path = require('path')

const XML_FMT = 'xml'
const TEXT_FMT = 'text'
const JSON_FMT = 'json'
const HTML_FMT = 'html'

const FORMATS = [XML_FMT, TEXT_FMT, JSON_FMT, HTML_FMT]

/**
 *  Inspect the resource graph and generate a sitemap.
 *
 *  Suppported formats are `xml`, `text`, `json` and `html`.
 *
 *  Enable this plugin for the `emit` phase when writing the `text`, `xml` and
 *  `json` formats. For the `html` format the `transform` phase is recommended
 *  so the modified sitemap template is optimized.
 *
 *  The `xml` and `text` formats are designed to be exposed to robots to
 *  indicate how they should crawl the site whilst the `json` format allows
 *  programmatic processing of the sitemap, for example if you wanted to
 *  fetch resources after invalidating a CDN cache.
 *
 *  The `html` format is designed to be exposed to humans on your website to
 *  allow them to find relevant information. It generates an unordered list
 *  of the sitemap tree hierarchy. When using the `html` format you should also
 *  let us know the template that the list will be injected into using the
 *  `template` option.
 *
 *  The template file must have an HTML AST available and declare an element
 *  with an `id` attribute of `sitemap` the generated list will be injected as
 *  a child of that element. This allows you to work on the sitemap markup and
 *  styles as you would work with any other document and ensure the sitemap data
 *  is always consistent with the website structure.
 *
 *  @class SiteMap
 *
 *  @see /docs/api/graph-resources/ Graph Resources
 *  @see https://www.sitemaps.org/protocol.html Sitemap Protocol
 *  @see https://support.google.com/webmasters/answer/178636 Image Sitemaps
 *  @see https://support.google.com/webmasters/answer/80471 Video Sitemaps
 *  @see https://developers.google.com/webmasters/videosearch/sitemaps Videosearch
 */
class SiteMap {

  /**
   *  Create a SiteMap plugin.
   *
   *  The base URL used to make links absolute first uses the `base` option
   *  otherwise looks for a `url` configuration option and finally will try to
   *  extract the `homepage` from a `package.json` file in the current working
   *  directory.
   *
   *  When no `formats` are given the `xml` format is used.
   *
   *  The `name` option should not include a file extension.
   *
   *  The rules option allows you to set fields for the `xml` output based on
   *  regular expression test patterns, for example:
   *
   *  ```javascript
   *  {
   *    rules: [
   *      {
   *        test: /docs\//,
   *        changefreq: 'weekly',
   *        priority: 0.8
   *      }
   *    ]
   *  }
   *  ```
   *
   *  If `changefreq` is invalid it will be ignored, if `priority` is outside of
   *  the zero to one range it is clamped.
   *
   *  When the `image` option is set the `xml` output format will include image
   *  resources in documents. The `image:loc` node is always set to an absolute
   *  URL using the `src` attribute of the `img` element.
   *
   *  The meta data to add to the sitemap is extracted from attributes on the
   *  element so you can declare sitemap meta data in the HTML document.
   *  The attribute to XML node name map for `img` elements:
   *
   *  + `title`: image:title
   *  + `data-caption`: image:caption
   *  + `data-geo-location`: image:geo_location
   *  + `data-license`: image:license
   *
   *  Image elements in sitemap URLs have a limit of 1000 if the number of
   *  images in a page exceeds this limit the sitemap will only include the
   *  first 1000.
   *
   *  When the `video` option is set the `xml` output format will include video
   *  resources in documents. The `video:content_loc` node is always set to
   *  an absolute URL using the `src` attribute of the `video` element.
   *
   *  Video sitemap meta data is extracted from the element attributes. The
   *  attribute to XML node name map for `video` elements:
   *
   *  + `title`: video:title
   *  + `data-description`: video:description
   *  + `data-thumbnail-loc`: video:thumbnail_loc
   *  + `data-duration`: video:duration
   *  + `data-expiration-date`: video:expiration_date
   *  + `data-rating`: video:rating
   *  + `data-view-count`: video:view_count
   *  + `data-publication-date`: video:publication_date
   *  + `data-family-friendly`: video:family_friendly
   *  + `data-tag`: video:tag
   *  + `data-category`: video:category
   *  + `data-restriction`: video:restriction
   *  + `data-restriction-relationship`: video:restriction (relationship attribute)
   *  + `data-gallery-loc`: video:gallery_loc
   *  + `data-gallery-loc-title`: video:gallery_loc (title attribute)
   *  + `data-price`: video:price
   *  + `data-price-currency`: video:price (currency attribute)
   *  + `data-requires-subscription`: video:requires_subscription
   *  + `data-uploader`: video:uploader
   *  + `data-uploader-info`: video:uploader (info attribute)
   *  + `data-platform`: video:platform
   *  + `data-platform-relationship`: video:platform (relationship attribute)
   *  + `data-live`: video:live
   *
   *  For the `data-tag` attribute you can separate multiple tags with a comma
   *  and they are expanded to multiple `video:tag` elements in the xml.
   *
   *  If the video element contains child `embed` elements a `video:player_loc`
   *  xml element is created for each child `embed` element with a `src`
   *  attribute.
   *
   *  Videos are also limited to 1000 per page.
   *
   *  No validation is performed on the video attributes you should read the
   *  corresponding documentation to verify attribute values are correct.
   *
   *  You can pass options specific to a format using the `renderer` option
   *  and the format key, for example:
   *
   *  ```javascript
   *  {
   *    renderer: {
   *      html: {
   *        builder: CustomHtmlBuilder
   *      }
   *    }
   *  }
   *  ```
   *
   *  When the `robots` option is set you should have a `robots.txt` file being
   *  processed and enabled the `parse-robots` plugin otherwise the option will
   *  have no effect. When configured correctly this option adds `Sitemap`
   *  entries for the robots.txt file for the `text` and `xml` formats.
   *
   *  If you are creating sitemaps in both `text` and `xml` formats two
   *  `Sitemap` entries will be created.
   *
   *  @constructor SiteMap
   *
   *  @param {Object} context the processing context.
   *  @param {Object} options the plugin options.
   *
   *  @option {String} [base] URL for the site domain.
   *  @option {String} [path] name of a sub-directory path.
   *  @option {String=index.html} [index] name of index documents.
   *  @option {String=sitemap} [name] name of the output file.
   *  @option {String|Array=xml} [formats] list of output formats to emit.
   *  @option {Array} [rules] set `changefreq`, `priority` fields for xml.
   *  @option {Boolean=true} [clean] use clean URLs for index documents.
   *  @option {Boolean=true} [slash] use trailing slashes.
   *  @option {Boolean=false} [robots] add `Sitemap` entries to robots.txt.
   *  @option {Boolean=false} [image] generate image xml entries.
   *  @option {Boolean=false} [video] generate video xml entries.
   *  @option {Boolean=false} [include] should the sitemap template be included.
   *  @option {Number=0} [indent] number of spaces to indent.
   *  @option {String=sitemap.html} [template] template for the HTML format.
   *  @option {Object} [renderer] format specific renderer options.
   *
   *  @throws Error if no resource graph is available.
   *  @throws Error if no base URL is available.
   *  @throws Error if an unknown format is detected.
   */
  constructor (context, options = {}) {
    if (!context.graph) {
      throw new Error(`sitemap expects a resource graph, use graph-resources`)
    }

    this.base = options.base || context.options.url

    if (!this.base) {
      let pkg
      try {
        pkg = require(path.join(process.cwd(), 'package.json'))
        this.base = pkg.homepage
      } catch (e) {}
    }

    if (!this.base) {
      throw new Error(`sitemap expects a base URL`)
    }

    if (options.path) {
      let rel = options.path
      // relative path must have a trailing slash
      if (!/\/$/.test(rel)) {
        rel += '/'
      }
      this.base = url.resolve(this.base, rel)
    }

    if (typeof options.formats === 'string') {
      options.formats = [options.formats]
    }

    this.index = options.index || 'index.html'
    this.template = options.template || 'sitemap.html'
    this.name = options.name || 'sitemap'
    this.formats = Array.isArray(options.formats) ? options.formats : [XML_FMT]
    this.rules = Array.isArray(options.rules) ? options.rules : []
    this.clean = options.clean !== undefined ? options.clean : true
    this.slash = options.slash !== undefined ? options.slash : true
    this.image = options.image !== undefined ? options.image : false
    this.video = options.video !== undefined ? options.video : false
    this.include = options.include !== undefined ? options.include : false
    this.indent = typeof options.indent === 'number'
      ? Math.abs(options.indent) : 0

    this.formats.forEach((fmt) => {
      if (!~FORMATS.indexOf(fmt)) {
        throw new Error(`unknown sitemap format: ${fmt}`)
      }
    })

    this.renderer = options.renderer ? options.renderer : {}
    this.options = options
  }

  getHref (id) {
    return id.split(path.sep).join('/')
  }

  getURL (id) {
    const href = this.getHref(id)
    if (/^https?:/.test(href)) {
      return href
    }
    let uri = url.resolve(this.base, href)
    const ind = uri.indexOf(this.index)
    if (this.clean && ind === (uri.length - this.index.length)) {
      uri = uri.substr(0, ind)
    }
    // remove trailing slash from directory paths
    if (!this.slash && /\/$/.test(uri)) {
      uri = uri.substr(0, uri.length - 1)
    }
    return uri
  }

  getRenderer (format) {
    return require('./lib/' + format)
  }

  getRendererOptions (format) {
    const rendererOptions = Object.assign(
      {}, this.options, this.renderer[format] || {})
    rendererOptions.base = this.base
    rendererOptions.index = this.index
    rendererOptions.indent = this.indent
    rendererOptions.image = this.image
    rendererOptions.video = this.video
    rendererOptions.template = this.template
    rendererOptions.clean = this.clean
    rendererOptions.slash = this.slash

    // helper to get an absolute URL derived from the base
    rendererOptions.absolute = this.getURL.bind(this)

    return rendererOptions
  }

  /**
   *  Generate the sitemap.
   *
   *  When the `exclude` option is given each entry should be a regular
   *  expression pattern. If a pattern matches an HTML document id in the
   *  resource graph it is not included in the sitemap.
   *
   *  @function before
   *  @member SiteMap
   *
   *  @param {Object} context the processing context.
   *  @param {Object} options the plugin options.
   *
   *  @option {Array} exclude list of regular expressions to exclude.
   */
  before (context, options) {
    const log = context.log
    const exclude = options.exclude || SiteMap.exclude
    const documents = context.graph.htmlDocuments
    const sitemap = {files: [], rules: this.rules}
    log.info('[sitemap] %s (%s documents)', this.base, documents.length)
    documents.forEach((doc) => {
      if (Array.isArray(exclude)) {
        for (let i = 0; i < exclude.length; i++) {
          if (exclude[i].test(doc.id)) {
            return
          }
        }
      }

      // do not include the sitemap itself
      if (!this.include && doc.id === this.template) {
        return
      }
      sitemap.files.push({
        url: this.getURL(doc.id),
        href: this.getHref(doc.id),
        key: doc.id,
        doc: doc
      })
    })

    this.formats.forEach((format) => {
      const renderer = this.getRenderer(format)
      const result = renderer.render(
        context, sitemap, this.getRendererOptions(format))
      sitemap.result = result

      // assign to the context for further processing if necessary
      // for example you could configure this plugin with the json format
      // in a much earlier phase than `emit` and add other plugins that
      // operate on the sitemap AST
      context.sitemap = sitemap

      const content = result.content

      // add the rendered content to be emitted
      // the HTML format does not return content as
      // it modfies the template AST
      if (content) {
        const filename = `${this.name}.${renderer.extension}`
        // 50 megabytes
        const limit = 52428800
        const length = Buffer.byteLength(content)

        /* istanbul ignore next: not going to mock huge file */
        if (length > limit) {
          log.warn('[sitemap] file too large %s (%s bytes)', filename, length)
        }

        log.info('[sitemap] %s (%s bytes)', filename, length)

        context.list.add({
          name: filename,
          output: path.join(context.options.output, filename),
          content: content
        })

        if (this.options.robots &&
            (format === XML_FMT || format === TEXT_FMT)) {
          this.updateRobots(context, filename)
        }
      }
    })
  }

  updateRobots (context, output) {
    const log = context.log
    const href = this.base + '/' + output.replace(path.sep, '/')
    const doc = context.graph.map['robots.txt']
    if (doc && doc.file.ast.robots) {
      const ast = doc.file.ast.robots
      const key = 'Sitemap'
      let sitemap
      ast.walk((node) => {
        if (node.key === key && node.value === href) {
          sitemap = node
        }
      })
      // do not create duplicate entries - might confuse the bots ;)
      if (!sitemap) {
        ast.dirty = true
        ast.result.append(key, href)
        doc.file.update()
        log.info('[sitemap] updated robots.txt with %s', href)
      }
    }
  }

  static get exclude () {
    return [/google[a-z0-9]+\.html$/i, /404\.html$/]
  }
}

module.exports = SiteMap
